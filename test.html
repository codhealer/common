<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
    <meta data-hid="apple-mobile-web-app-capable" name="apple-mobile-web-app-capable" content="yes" />
    <meta data-hid="apple-mobile-web-app-status-bar-style" name="apple-mobile-web-app-status-bar-style" content="black" />
    <title>test</title>
  </head>

  <body>
    <div></div>
    <script>
      /*
       * 频率控制 返回函数连续调用时，fn 执行频率限定为每多少时间执行一次
       * @param fn {function}  需要调用的函数
       * @param delay  {number}    延迟时间，单位毫秒
       * @param immediate  {bool} 给 immediate参数传递false 绑定的函数先执行，而不是delay后后执行。
       * @return {function}实际调用函数
       */
      var throttle = function(fn, delay, immediate, debounce) {
        var curr = +new Date(), //当前事件
          last_call = 0,
          last_exec = 0,
          timer = null,
          diff, //时间差
          context, //上下文
          args,
          exec = function() {
            last_exec = curr
            fn.apply(context, args)
          }
        return function() {
          curr = +new Date()
          ;(context = this), (args = arguments), (diff = curr - (debounce ? last_call : last_exec) - delay)
          clearTimeout(timer)
          if (debounce) {
            if (immediate) {
              timer = setTimeout(exec, delay)
            } else if (diff >= 0) {
              exec()
            }
          } else {
            if (diff >= 0) {
              exec()
            } else if (immediate) {
              timer = setTimeout(exec, -diff)
            }
          }
          last_call = curr
        }
      }

      /*
       * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay，fn 才会执行
       * @param fn {function}  要调用的函数
       * @param delay   {number}    空闲时间
       * @param immediate  {bool} 给 immediate参数传递false 绑定的函数先执行，而不是delay后后执行。
       * @return {function}实际调用函数
       */

      var debounce = function(fn, delay, immediate) {
        return throttle(fn, delay, immediate, true)
      }

      var code = 1

      function test(params) {
        console.log(code, '---')
        code++
      }

      var code1 = 1

      function test1(params) {
        console.log(code1, '--------')
        code1++
      }

      // document.addEventListener('mousemove', () => {
      //   // return debounce(test, 2000)
      //   return throttle(test1, 2000)
      // })

      document.addEventListener('mousemove', debounce(test, 2000))
      // document.addEventListener('mousemove', throttle(test1, 2000))
      // debounce(test(), 2000)
      // throttle(test1(), 2000, {
      //   leading: false,
      //   remaining: false
      // })
    </script>
  </body>
</html>
